var input = @"#.#.####.###...###..#....#.....##.#.#.#..#.#.#######...##...#..###..#..
#..##..####.#.#....##..#...##.#.#.######.....##.#.########....####...##
.##.#....##.#..#####...#.#.##.....#...##..##...#####.##.#########...#..
..##.###.#.###.#.#.#.#...#..#.###..#.....##.....#.#.......####...#.##..
..#####...##...#...###.##..###...#..#.##...##...#.#.#.##...##.#..##...#
##..########...###.#.#####.#..##..######.#....#....##.#..####..#####.#.
.....###...#.#.###.###......#.#.#...#.##.#..##.#.#...#...###.#...#.#..#
..##......#..##.#.#######.##.....###.....###..#..#..#.##.#....#.#..###.
####..##..###.####.#.#.##...#..####..#...#.######..##....#.#.#..#######
####.#..###########.....#..###.#..#...##.#.####.....##.##..#...#..##...
#.##.##.#...#.....#..#.###.#.#.#..##.#####..#..#..###.###.###...###.##.
.#..#.######...##...##.#.###..###.....###.#..###...##.#.###....##.####.
###.#..##.....####.###.##..##.##..#...#...#.#....#.#.##.#..#.#...#.#.#.
...####..###.#..#..###..#...#.#..######.##..#....##.#######.....#.#..#.
#.#.#.##.#.#.##..##...#.#...#...##.#.###.#...#..#..#.##..##.######...##
.#.#...#.#.#.#..#.#......#.##########..###...##.#..#####.##.###..#.#.##
.###..#..####..##......#..#..#.##...##.#.#....##.#..#.#..##.#...#.##...
#.#.......###.#.###.##.##.##.......###...#....#.####.##.#..#.##.##.####
.######...#.###.###.#.#.##.##.#.#.......##.##.##.###.##......#.#..#.#..
..##.##..####.#..##.#.#....#.#...#..#....###.##.#.....##.#.##.####.###.
....##...##.####.#....##.....#.####..#.####.#.##..###..##.##..#..##..##
..##.####...##.#.#.#..#.#..#.....####..###..#.###...#.#####..##......##
###..#.#####.###.#..###.#....##.##.....#.#.###.#....##...##..#....##.#.
#.##.#####..##.###.#......#.#####..#....#..#....####.#######.##.#######
.##.##.#..#...##.#.##.#.###.#.##.########.##....#.##...####.#.####.###.
#.#.##.######.#...####.###.#.#..#.####....#...####.####.....###.##.####
..##..##......#.#.#.#..##.#.#..#.##.####.#.###...##........#.####..##..
#....###.##..###....#.##.#..#.#####.#..##.###.##.##...#.###......#.#..#
.##.##.....#.#.##.#.##.###.##...#.#.###.#.####.###........#.#..###.#..#
.#...##..##.#.#.####.....#.#..#..#.#####..##..#####.######..#....######
##.##.##.###.#..#..#.###.#...##.##.#..###....##.#..#.##.##........###.#
...#..###.#####....#....#..#.#...#...#...#.#...##..##.#.#.##.###..#.#.#
###.#####.#.###..#.#...#.#.#######.#..##.#.....##.#..##.......#.##.#.#.
#..#.##..##.##....#..#..##...###.#.#....#...#.##.#.##.#...##.....##.##.
###..#.#.#.......###.####...###...##.....#..#............#..###..#.#...
.....#..#..#..###.#.##.###.#.#..##...##...#.#.#..#.###.##.##..#####.##.
...#.#..#.###..#....#.##..#.#..##.#...#.####.#.#.....#..#.##..###.#####
##.##..#.#.###.#.#.#....#.#...###.#.#.#.#..#.#.#..##..##.####.##..##..#
..#.....#.#...#..#.#...#..##.....#####..#.....#..##..#..######..#......
.##.....#.#...##....#....####..#.#..###.#.##.#####.....##..##..#.###.##
....###..#...##..###.##..#..#....#.###.#.##.....#....#.###.##.###.#....
........#.####.#.#.###..#..#.#.###......##.##.##..#.#..#.#...##.#.....#
..###.##.#..#.#....#.##......#.#...#.#.###.##.##.#......#.####.##.##.#.
#...#####..###.###...#...##..#.#.###..#..####....#.#.#####.#.########..
#####.....##..#...##..###......#.##..#.#..##.###.###..#.##..#.#.#......
#....#.##.##.#.#..#.####.###..#.###.###.#.#..#.....#####.####...##.####
##.####......#..#.#..#..#....##.##....##.##.##.####.....#..#.###.##.#..
.###...#.#....######..#.#.#......#..#.#...######..#.##.##...#.##.....#.
#..#########....##...##.#..##.#..##.#..#####.......#..##.###....###..##
#...#.#.#...#...##.##...#####...#####.....##...#..#.##..#####.##....#.#
##..#....#..###.##..###..##.##..###...##.#.##.#...#...#.##.##.##..##.#.
#.#.#...##.##..#...###.#.....#....#....##...#.##...#.#.#.##.#####..###.
#####....##.####.#..##...##..###....#....#.##.#..#######..###..###.....
#.####..####.#.##.##.#.#####.#.##..#.....#.#..##............##..#...###
.######...#..###.###.##..#...###..#....#.##.....###.#....##..##.#####.#
###..#......#.##.#.#..#.#....###.##...#.##.#..##.#.#####....###....###.
#######.#.#....####....##....##.####....#.#####.##.####.###.###..#.##..
.#..##...####.#.#...###.#.##...####...#.##..##...#..##.#####..##..##..#
#...#...#..###.#.####.#####.####..#....#....##.....#.#####.#.#....###.#
#..##.#.#.....##..#....##..#.#...##...##..#..####.##......#...#.#...#..
###..#####...#..##..##..##...###...###.###.##...#...#####.####.####.#.#
.#...#.#..##.#....#.###..#....#.......#.##..##.###..#.####..#.#.####...
.#..##.#.....##.###..##...##.#.####...#.#..#..######..###..##..##..###.
...#.###..#.##....#####..######..#..##.######..#.#..#....###.....##....
.##...#####..##..#..#.#.........#...##.##..#.#..#.##.##........###..#..
##.##..#...###.#####...#...##..#.#....#...##..##.##...#.#.##...#.#.#.#.
..#####.#..###.....##..#..##.##..###.#.##.#.#.#.###.######..####.##.###
####.###.#.##...#.###..#########.#...##..#..#..#.###.###.####.###....#.
#..###.####..##.#.##..#...#.#.#.##...#..#.#####.......#.##.#....#..####
##....#.##.######......##.#####.#....#.##....#####.#.#...##..#.#.#.#..#
..##.##....##.###......#..##.###..##.##.####....#..#.##.....#.##.###.#.";
var testInput = @"....#..
..###.#
#...#.#
.#...##
#.###..
##.#.##
.#..#..";

var parsed = input.Split("\n");

var map = new char[1000][];

for (int y = 0; y < 1000; y++)
{
    map[y] = new char[1000];
    for (int x = 0; x < 1000; x++)
    {
        map[y][x] = '.';
    }
}

var elves = new List<Elf>();
for (int y = 0; y < parsed.Length; y++)
{
    var line = parsed[y];
    for (int x = 0; x < line.Length; x++)
    {
        var ch = line[x];

        if (ch == '#')
        {
            elves.Add(new Elf
            {
                Position = new Point2d
                {
                    X = x + 200,
                    Y = y + 200,
                }
            });

            map[y +200][x + 200] = '#';
        }
    }
}

var moveDirs = new List<Direction>
{
    new Direction
    {
        // North
        Move = new Point2d { X = 0, Y = -1 },
        PositionsToCheck = new List<Point2d>
        {
            new Point2d { Y = -1, X = 0 },
            new Point2d { Y = -1, X = 1 },
            new Point2d { Y = -1, X = -1 }
        }
    },
    new Direction
    {
        // South
        Move = new Point2d { X = 0, Y = 1 },
        PositionsToCheck = new List<Point2d>
        {
            new Point2d { Y = 1, X = 0 },
            new Point2d { Y = 1, X = 1 },
            new Point2d { Y = 1, X = -1 }
        }
    },
    new Direction
    {
        // West
        Move = new Point2d { X = -1, Y = 0 },
        PositionsToCheck = new List<Point2d>
        {
            new Point2d { X = -1, Y = 0 },
            new Point2d { X = -1, Y = 1 },
            new Point2d { X = -1, Y = -1 }
        }
    },
    new Direction
    {
        // East
        Move = new Point2d { X = 1, Y = 0 },
        PositionsToCheck = new List<Point2d>
        {
            new Point2d { X = 1, Y = 0 },
            new Point2d { X = 1, Y = 1 },
            new Point2d { X = 1, Y = -1 }
        }
    },

};
var allDirs = new List<Point2d>
{
    // East + Diag
    new Point2d {X = 1, Y = 0},
    new Point2d {X = 1, Y = 1},
    new Point2d {X = 1, Y = -1},

    // West + Diag
    new Point2d {X = -1, Y = 0},
    new Point2d {X = -1, Y = 1},
    new Point2d {X = -1, Y = -1},

    // North & South
    new Point2d {X = 0, Y = 1},
    new Point2d {X = 0, Y = -1},
};

Debug();

var res = 0;
for (int i = 0; i < 1000; i++)
{
    // First evaluate proposition for each elf
    foreach (var elf in elves)
    {
        EvaluateMovementProposition(elf);
    }


    // Then evaluate for each group of proposed pos that is only 1 the new pos
    var hasMoved = ProcessMovements();
    if (!hasMoved)
    {
        res = i + 1;
        break;
    }

    // Then push the dir back and reset the elves
    PushFirstDirBack();
    foreach (var elf in elves)
    {
        elf.ProposedPosition = null;
    }

    // Then rewrite the map
    ResetMap();

    // Debug
    Debug();
}

// Find smallest rectangle
//var minX = elves.OrderBy(e => e.Position.X).First().Position.X;
//var minY = elves.OrderBy(e => e.Position.Y).First().Position.Y;
//var maxX = elves.OrderByDescending(e => e.Position.X).First().Position.X;
//var maxY = elves.OrderByDescending(e => e.Position.Y).First().Position.Y;

//for (int y = minY; y <= maxY; y++)
//{
//    for (int x = minX; x <= maxX; x++)
//    {
//        Console.Write(map[y][x]);
//        if (map[y][x] == '.') res++;
//    }
//    Console.Write('\n');
//}
//Console.Write('\n');
//Console.Write('\n');

Console.WriteLine(res);

void Debug()
{
    return;

    // Debug
    for (int y = 198; y < 215; y++)
    {
        for (int x = 197; x < 213; x++)
        {
            Console.Write(map[y][x]);
        }
        Console.Write('\n');
    }
    Console.Write('\n');
    Console.Write('\n');
}

void ResetMap()
{
    for (int y = 0; y < 1000; y++)
    {
        for (int x = 0; x < 1000; x++)
        {
            map[y][x] = '.';
        }
    }

    foreach (var elf in elves)
    {
        map[elf.Position.Y][elf.Position.X] = '#';
    }
}

bool ProcessMovements()
{
    bool hasMoved = false;

    foreach (var grouping in elves.Where(e => e.ProposedPosition is not null).GroupBy(e => e.ProposedPosition))
    {
        if (grouping.Count() > 1) continue;

        hasMoved = true;
        var elf = grouping.First();
        elf.Position.X = elf.ProposedPosition.X;
        elf.Position.Y = elf.ProposedPosition.Y;
    }

    return hasMoved;
}

void EvaluateMovementProposition(Elf elf)
{
    if (IsElfAlone(elf))
    {
        elf.ProposedPosition = null;
        return;
    }

    foreach (var direction in moveDirs)
    {
        var dir = direction.Move;

        if (CheckPropositionMove(elf, direction))
        {
            elf.ProposedPosition = new Point2d
            {
                X = elf.Position.X + dir.X,
                Y = elf.Position.Y + dir.Y
            };
            return;
        }
    }

    elf.ProposedPosition = null;
}

bool CheckPropositionMove(Elf elf, Direction direction)
{
    foreach (var positionToCheck in direction.PositionsToCheck)
    {
        if (map[elf.Position.Y + positionToCheck.Y][elf.Position.X + positionToCheck.X] == '#')
        {
            return false;
        }
    }

    return true;
}

bool IsElfAlone(Elf elf)
{
    foreach (var dir in allDirs)
    {
        if (map[elf.Position.Y + dir.Y][elf.Position.X + dir.X] == '#')
        {
            return false;
        }
    }

    return true;
}

void PushFirstDirBack()
{
    var dir = moveDirs[0];
    moveDirs.Remove(dir);
    moveDirs.Add(dir);
}

public class Direction
{
    public Point2d Move { get; set; }
    public List<Point2d> PositionsToCheck { get; set; }
}

public class Elf
{
    public Point2d Position { get; set; }
    public Point2d ProposedPosition { get; set; }
}

public class Point2d : IEquatable<Point2d>
{
    public int X { get; set; }
    public int Y { get; set; }

    public bool Equals(Point2d other)
    {
        if (ReferenceEquals(null, other)) return false;
        if (ReferenceEquals(this, other)) return true;
        return X == other.X && Y == other.Y;
    }

    public override bool Equals(object obj)
    {
        if (ReferenceEquals(null, obj)) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != this.GetType()) return false;
        return Equals((Point2d)obj);
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(X, Y);
    }
}